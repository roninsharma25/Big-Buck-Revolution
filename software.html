<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Software Design</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.15.3/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
            <div class="container">
                <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ml-auto">
                        <li class="nav-item"><a class="nav-link" href="index.html">Home</a></li>
                        <li class="nav-item"><a class="nav-link" href="about.html">About</a></li>
                        <li class="nav-item"><a class="nav-link" href="hardware.html">Hardware Design</a></li>
                        <li class="nav-item"><a class="nav-link" href="software.html">Software Design</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Page Header-->
        <header class="masthead" style="background-image: url('assets/img/contact-bg.jpg')">
            <div class="overlay"></div>
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-md-10 mx-auto">
                        <div class="page-heading">
                            <h1>Software Design</h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        <!-- Main Content-->
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-md-10 mx-auto">
                    <h2>Overview</h2>
                    <p>
                        We used the Model-View-Controller design pattern when structuring our code. This approach separated different 
                        aspects of the game, allowing us to use modularity. The models included game objects, so for our project the two 
                        models were arrows and buttons. Views display the models to the player, so we had draw methods for each of these models. 
                        In our project, we only had one view since we always drew models to the same screen and just varied the position.
                        The controllers updated the game state. We had a controller for each screen and each controller determined which models appeared 
                        on each screen, where they were drawn, and how the player could interact with them. In the following sections, we will explain 
                        these aspects of our code.
                    </p>

                    <h2>Models</h2>

                    <p>Our game had two models: Button and Arrow.</p>

                    <h4>Button Model</h4>

                    <p>
                        The button model was used to add interactive buttons to the game. On some screens, players have the option to navigate between different 
                        options, and each option is a button. For example, on the menu screen, players select the game type, so each game type is a button. In the class, 
                        for this model, there are attributes for the font, text, and text size. Additionally, when a player hovers over a button, it is highlighted.
                    </p>
                    <img src = "assets/img/highlightedText.png" style = "width: 200px; height: 200px; margin: -215px -200px 0px 0px;" align = "right";>
                    <p>
                        We have additional attributes that store whether the button is highlighted. The methods <i>setHighlighted</i> and <i>setSelected</i> 
                        updated these attributes. In this class, we also had a draw method, which we will discuss in the Views section. Lastly, we had an 
                        <i>updateText</i> method that changed the text of a button. This method was only used on one screen, but we still included it as a 
                        method to follow our modular design principle.
                    </p>

                    <h4>Arrow Model</h4>

                    <img src = "assets/img/arrow.png" style = "width: 100px; height: 100px; margin: 0px -125px 0px 0px;" align = "right";>
                    <p>
                        The arrow model was used to add stationary and moving arrows to the game. Each arrow had several attributes; we highlight the essential ones below.
                        <ul>
                            <li>Position - x and y coordinates of the arrow on the screen</li>
                            <li>Speed/Approach Rate - how fast the arrow moves down the screen</li>
                            <li>Direction - orientation of the arrow (left, right, up, down)</li>
                            <li>Note Time - absolute time when the arrow should be pressed</li>
                        </ul>
                        
                        The arrow class had draw and update methods, which we will discuss in the Views and Controllers sections. It also had position getters to obtain the x 
                        and y positions of individual arrows. We included a delete method to remove the arrow from the screen. Lastly, we added a format method which returned 
                        relevant information about an arrow (note time, direction) in an easily parsable list format.
                    </p>

                    <h2>Controllers</h2>

                    <p>
                        We had seven controllers in our game.
                        <ul>
                            <li>Input Controller</li>
                            <li>Menu Controller</li>
                            <li>Select Controller</li>
                            <li>Difficulty Controller</li>
                            <li>Game Controller</li>
                            <li>Done Controller</li>
                            <li>Edit Controller</li>
                        </ul>
                    </p>

                    <h4>Input Controller</h4>

                    <p>
                        The input controller handled detecting user inputs, which were mainly the pressure pad inputs. The class had attributes for all four 
                        directions (left, right, up, down). The type of each attribute was a boolean, so it was <i>True</i> when the input was pressed, and <i>False</i>
                        otherwise. We also implemented software-side debouncing. To do this, we had attributes that stored the current 
                        and previous value for each direction. For example, for the left arrow input, we had two attributes: <i>prev_left</i> and <i>curr_left</i>. We defined 
                        functions that checked if any input pad was pressed (4 total). These functions checked if the current attribute is <i>True</i> and the previous attribute 
                        is <i>False</i>. It both conditions were <i>True</i>, then the input was pressed. We had more functions that used similar logic to check if inputs 
                        were released. This class also contained a <i>lightButton</i> method which used a PWM signal to light up the LEDs on the side of the dance pad.
                    </p>

                    <h4>Menu Controller</h4>

                    <img src = "assets/img/mainMenu.png" style = "width: 250px; height: 250px; margin: 0px -275px 0px 0px;" align = "right";>
                    <p>
                        The Menu Controller handled updating the main menu screen based on user inputs. It had three buttons, 'Single Player', 'Multiplayer', and 'Level Editor'. 
                        When the player selected one of those options, this controller updated its <i>exitCode</i> attribute. We used this same convention in all our controllers 
                        to transition between screens. The controller would set the attribute based on the button that was selected and then the top level script (<i>game.py</i> which we 
                        will discuss later) transitioned to the next screen based on the attribute's value.
                    </p>

                    <img src = "assets/img/songSelect.png" style = "width: 250px; height: 250px; margin: 0px 0px 0px -275px;" align = "left";>
                    <h4>Select Controller</h4>

                    <p>
                        The Select Controller handled the song selector screen. On this screen, all of the possible songs were displayed, and the user had to select one of them. This 
                        controller was very similar to the Menu Controller, as its main functionality was updating its <i>exitCode</i> attribute, so that the top level script could 
                        ensure the game started with the selected song.
                    </p>

                    <img src = "assets/img/difficultySelector.png" style = "width: 250px; height: 250px; margin: 0px -275px 0px 0px;" align = "right";>
                    <h4>Difficulty Controller</h4>

                    <p>
                        The Difficulty Controller handled the difficulty selector screen. This was also very similar to the Menu Controller and Select Controller. The main difference 
                        was that it prompted the user with a bunch of images along with a yes or no question. If the player selected yes, there would be an animation playing in the background 
                        while the game was in progress, which was the harder difficulty. If the player selected no, there would be no animation.
                    </p>

                    <h4>Game Controller</h4>

                    <p>
                        The Game Controller handled updating the main game screen. This controller was the heart of our project, since it contained the code for the actual game, 
                        and thus it was the longest file with the most logic. This controller can be broken up into two sections: game setup and gameplay.
                    </p>

                    <h5>Game Setup</h5>

                    <p>
                        The fundamental aspect of the game is that arrows move down the screen and the player has to hit the corresponding pressure pad when an arrow reaches 
                        the bottom. A major component is the timing of the arrows, since arrows reaching the bottom should correspond to beats in the song being player. We created 
                        JSON files that stored this timing information for each song. Below is an example JSON file, with a subset of arrows for space purposes.
                    </p>

                    <img src = "assets/img/exampleJSON.png" style = "width: 400px; height: 400px;">

                    <p>
                        The file field stores the MP3 audio file of the song. The BPM field stores the beats per minute in the song. The startTime field is the absolute time 
                        at which the first note should reach the bottom. The approachRate field is how fast the arrows in the song should move down the screen. The arrows field is 
                        a list that contains one entry (sublist) per arrow in the song. Each arrow sublist contains three values. First, it contains the time the arrow should reach the 
                        bottom, relative to startTime. Second, it contains the direction of the arrow, which is represented as a number from 0-3 (0: left, 1: down, 2: up, 3: right). 
                        Lastly, it contains the duration of the note. <i>Currently, the game only supports arrows with duration 0 (single pressure pad tap).</i> We analyzed each 
                        song using Audacity to determine the beat times, and then created arrows at those times.
                    </p>

                    <p>
                        In Game Controller, we use the <i>parseSong</i> function to extract all of this information from the JSON corresponding to the selected song, 
                        and save it in different attributes. During this process, we convert all the relative arrow times to absolute times, based on the start time. 
                        Next, we created our two lists of arrows: moving and stationary arrows. Our <i>createArrows</i> function took the parsed output and generated 
                        the list of moving arrows. This function also created the stationary arrows, which were the four arrows at the bottom. The purpose of these 
                        arrows was to specify when the user had to press one of the pressure pads. In other words, players had to hit the pressure pads when the moving 
                        arrows overlapped with the stationary arrows. In addition to the four stationary arrows that always appeared on the screen, we also had outlines 
                        of each of the four stationary arrows. These outlines were displayed when the player pressed one of the pressure pad. This provided the player with 
                        a visual confirmation that the system was properly detecting their input. This controller then started the music, started the time, and initialized the score 
                        and other game statistics that we tracked. It also determined the game background based on the difficulty.
                    </p>

                    <h5>Gameplay</h5>

                    <img src = "assets/img/easyEx.png" style = "width: 250px; height: 250px; margin: 150px 0px 00px -275px;" align = "left";>
                    <img src = "assets/img/challengeEx.png" style = "width: 250px; height: 250px; margin: 150px -250px 0px 0px;" align = "right";>
                    <p>
                        Based on the user input from the Input Controller, the Game Controller checks if the player pressed the correct arrow at the right time. Our implementation 
                        finds the closest arrow about the bottom of the screen based on the pressure pad. For example, if the player presses the left pressure pad, the Game Controller 
                        will find the closest left arrow above the bottom. If that arrow is within a range off of the center of the stationary arrow, it will be classified as a hit, 
                        and the player will get the maximum number of points. If the arrow is not within the range but is within twice the range, then it will be classified as 
                        almost a hit, so the player will receive a reduced number of points. Otherwise, the player will receive no points. Based on if the arrow is classified as a hit, 
                        almost hit, or miss, the Game Controller also updates the extra statistics (total hits, total notes, points received, total score). Additionally, we implemented 
                        a multiplier. The multiplier starts at 1 and increments by 0.5 for every arrow that is a hit and increments by 0.25 for every arrow that almost hits. The player's 
                        score increment for each arrow is multiplied by the multiplier. When a player misses an arrow the multiplier is reset to 1, so players can achieve higher scores 
                        by stringing together several hits (or almost hits) in a row. Following the classification of hit/almost hit/miss, the arrow is deleted. Here are all 
                        the statistics displayed during the game.
                    </p>
                    
                    <img src = "assets/img/stats.png" style = "width: 400px; height: 300px; margin: 0px 0px 0px 150px;" align = "center";>
                    
                    <p>
                        At this point, the Game Controller notifies the Input Controller to display a certain color on the dance pad's LEDs. 
                        Green represents a hit, blue represents an almost hit, and red represents a miss. Lastly, the Game Controller sets its <i>done</i> attribute 
                        to be <i>True</i> after the last arrow hits the bottom, signalling the end of the game. Similar to the previous controllers, the main script, <i>game.py</i> 
                        constantly reads this attribute and switches to the next stage of the game accordingly.

                    </p>

                    <h4>Done Controller</h4>

                    <p>
                        The Done Controller handled the post-game screen, which displayed the player's score, showed the song's leaderboard, and allowed the player 
                        to submit their name and score to the leaderboard. We used a JSON to store all of the leaderboard data for each song, which is depicted below.
                    </p>

                    <img src = "assets/img/exampleLeaderboard.png" style = "width: 400px; height: 400px;">

                    <p>
                        The JSON stored a separate leaderboard for each song. For each song, it stored three letters as the player's name along with their score. 
                        When the game ended, the Done Controller loaded up the leaderboard for the song that the player selected and displayed all the previous scores. 
                        We used one button, which started as 'Enter Name', for allowing the player to submit their name and score to the leaderboard. The player was able 
                        to use the left and right pressure pad inputs to move between the three letters, and was able to use the up and down pressure pad inputs to cycle 
                        between letters. Below is an example leaderboard. The leaderboard gets updated right after the player submits their name, and it is automatically 
                        sorted in decreasing order.
                    </p>

                    <img src = "assets/img/exLeaderboard.png" style = "width: 300px; height: 300px; margin: 0px 0px 0px 175px;" align = "center">

                    <p>
                      Here are examples of the entire Done Controller screen before and after the players submit their name and score.  
                    </p>
                    <img src = "assets/img/doneExBefore.png" style = "width: 300px; height: 300px; margin: 0px 100px 50px 0px;" align = "left">
                    <img src = "assets/img/doneExAfter.png" style = "width: 300px; height: 300px; margin: 0px 0px 50px 0px;" align = "right">


                    <h4>Edit Controller</h4>

                    <img src = "assets/img/levelEditor.png" style = "width: 250px; height: 250px; margin: 50px -250px 0px 0px;" align = "right";>
                    <p>
                        The Edit Controller handled the level editor. We created some levels ourselves, but also implemented a level editor to allow the player to create 
                        levels. This controller streamed the arrows the player was inputting. Specifically, it played the song the user selected, then the user was allowed 
                        to use the pressure pads to specify arrows. The Edit Controller saved the absolute times of each of these arrows along with the direction. Once the 
                        song ended, the arrows were played back, with the song, so that the player could assess if there needed to be any changes to the level. The arrows 
                        were saved to a JSON so the player had the freedom to edit the JSON file, specifically some arrow's note times, if they felt that some times 
                        were off.
                    </p>

                    <h2>Views</h2>

                    <p>
                        Our game only had one view, since we were always drawing to the screen on the Pi or an external monitor. We had a draw method in each model. 
                        As it sounds, this method drew the model to the screen. Each controller called a model's draw method based on what needed to be displayed on the 
                        screen at a specific time. For example, on the Main Menu, there were three buttons. The draw method in the Menu Controller called the draw method 
                        for each of the three buttons it instantiated.
                    </p>

                    <p>
                        One optimization that we implemented was the number of arrows we drew during the game. We had one list of arrows, but it was fairly computationally 
                        expensive to constantly draw each of these arrows. Therefore, we stored the indices of the first and last arrow that we wanted to draw. We constantly 
                        updated these indices as the song progressed, but this made the code more efficient since it didn't loop through every arrow in the list.
                    </p>

                    <h2>Main Script</h2>

                    <p>
                        We have discussed the models, views, and controllers that we implemented. However, the script <i>game.py</i> is responsible for starting the game 
                        and coordinates the transitions between screens. First, this script initialized all seven of the controllers. Then, it ran the game until the physical 
                        quit button was pressed. This process can be modeled as a state machine. There were a total of six states:

                        <ul>
                            <li>STATE_MENU: Main Menu</li>
                            <li>STATE_SELECTSCREEN: Song Select</li>
                            <li>STATE_DIFFICULTY: Difficulty (background image) select</li>
                            <li>STATE_SINGLEPLAYER: Game running</li>
                            <li>STATE_EDITOR: Level editor</li>
                            <li>STATE_DONE: Game finished</li>
                        </ul>

                        Each state corresponded to its own screen, and was controlled but its own controller. In this script, there was an update method for each state. In this 
                        method, we called the update method for that state's controller and then checked for the inputs that would require a state transition. For example, 
                        if the current state was STATE_MENU, then the mupdate method in <i>game.py</i> first called the Menu Controller's update method. Then it checked 
                        if the player selected any of the three buttons on the menu screen. If the first option, single player, was selected then it started single player 
                        mode, and if another option was selected then it performed the appropriate steps and state transition.
                    </p>

                    <p>
                        Another extension that we implemented was multiplayer mode. We decided to allow the players to decide on one song. The game would start for player 1, 
                        then there would be a 10 second pause, and then the game would restart for player 2. Finally, the winner would be shown on the Done Controller's screen, 
                        and the winner would be allowed to upload their score to the leaderboard. To implement this we had to modify the transition logic between STATE_SINGLEPLAYER 
                        and STATE_DONE. STATE_SINGLEPLAYER was used to run one round of the game, and after it finished we restarted it if the players selected the multiplayer option. 
                        We chose this implementation instead of creating a separate multiplayer state since it helped keep the number of states concise and didn't introduce unncessary 
                        complexity. Lastly, we had to save both players scores and compare the two to check which player one. This was calculated by the Done Controller.
                    </p>

                    <img src = "assets/img/winnerEx.png" style = "width: 300px; height: 300px; margin: 0px 0px 0px 175px;" align = "center">

                </div>
            </div>
        </div>
        <hr />

        <!-- Bootstrap core JS-->
        <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Contact Form JavaScript-->
        <script src="assets/mail/jqBootstrapValidation.js"></script>
        <script src="assets/mail/contact_me.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
